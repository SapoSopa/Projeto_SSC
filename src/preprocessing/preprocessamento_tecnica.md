# M√≥dulo de Pr√©-processamento de Sinais ECG

Este m√≥dulo cont√©m fun√ß√µes essenciais para o pr√©-processamento de sinais ECG, especificamente otimizado para trabalhar com o dataset PTB-XL.

## üìä Classifica√ß√£o por Necessidade

**üî¥ CR√çTICAS**: `load_signal_data`, `aplicar_filtro`, `normalizar_sinal`  
**üü° IMPORTANTES**: `remover_baseline_drift`, `detectar_outliers`, `aplicar_janelamento`  
**üü¢ √öTEIS**: `verificar_qualidade_sinal`, `pipeline_preprocessamento`, `salvar_dados_processados`

---

## Fun√ß√µes Principais

### üî¥ 
#### ‚û°Ô∏è `load_signal_data(filepath: str) -> Tuple[np.ndarray, Dict[str, Any]]`

**Descri√ß√£o**: Carrega dados de sinal de arquivos WFDB (formato usado pelo PTB-XL dataset).

**Necessidade**: **CR√çTICA** - PTB-XL usa formato WFDB n√£o suportado nativamente pelo NumPy/Pandas.

**Par√¢metros**:
- `filepath`: Caminho para o arquivo de dados (sem extens√£o .hea/.dat)

**Retorna**:
- Tupla contendo:
  - Array numpy com os dados do sinal (amostras x canais)
  - Dicion√°rio com metadados (fs, sig_name, n_samples, n_channels)

**Exemplo de uso**:
```python
sinal, metadata = load_signal_data('./data/records100/00001_lr')
print(f"Frequ√™ncia de amostragem: {metadata['fs']} Hz")
print(f"N√∫mero de canais: {metadata['n_channels']}")
```

**Observa√ß√µes**:
- Compat√≠vel com formato WFDB usado no PTB-XL
- Trata automaticamente erros de carregamento
- Metadados incluem informa√ß√µes essenciais para processamento posterior
- Casting expl√≠cito para tipos Python nativos nos metadados

---

#### ‚û°Ô∏è `aplicar_filtro(sinal: np.ndarray, fs: int, tipo: str = 'bandpass', frequencias: Tuple[float, float] = (0.5, 45.0), ordem: int = 4) -> np.ndarray`

**Descri√ß√£o**: Aplica filtros digitais Butterworth ao sinal ECG para remo√ß√£o de ru√≠dos e artefatos.

**Necessidade**: **CR√çTICA** - ECG cl√≠nico cont√©m ru√≠dos que reduzem acur√°cia em >30%.

**Ru√≠dos removidos**: Interfer√™ncia de linha (50/60 Hz), deriva respirat√≥ria (0.05-0.5 Hz), ru√≠do muscular (>100 Hz).

**Par√¢metros**:
- `sinal`: Array numpy com shape (amostras, canais)
- `fs`: Frequ√™ncia de amostragem em Hz
- `tipo`: Tipo do filtro ('bandpass', 'lowpass', 'highpass')
- `frequencias`: Tupla com frequ√™ncias de corte (Hz)
- `ordem`: Ordem do filtro (padr√£o: 4)

**Retorna**:
- Sinal filtrado com mesmo shape do input

**Valida√ß√µes Implementadas**:
- **Entrada**: Verifica se sinal √© array numpy e dimens√µes v√°lidas
- **Frequ√™ncia**: Valida fs > 0 e frequ√™ncias dentro de limites de Nyquist
- **Tipo**: Verifica tipos de filtro suportados
- **Consist√™ncia**: Para bandpass, verifica freq_baixa < freq_alta

**Filtros Recomendados para ECG**:
- **Bandpass (0.5-45 Hz)**: Remove deriva da linha de base e ru√≠do de alta frequ√™ncia
- **Highpass (0.5 Hz)**: Remove apenas deriva da linha de base
- **Lowpass (45 Hz)**: Remove ru√≠do de alta frequ√™ncia mantendo componentes do ECG

**Exemplo de uso**:
```python
# Filtro passa-banda padr√£o para ECG
sinal_filtrado = aplicar_filtro(sinal, fs=500, tipo='bandpass', frequencias=(0.5, 45.0))

# Filtro passa-alta para remover deriva
sinal_sem_deriva = aplicar_filtro(sinal, fs=500, tipo='highpass', frequencias=(0.5,))
```

**Observa√ß√µes**:
- Usa `filtfilt` para filtragem de fase zero (preserva morfologia)
- Verifica automaticamente frequ√™ncias de Nyquist com warnings
- Trata sinais 1D e 2D automaticamente
- 0.5 Hz baixa preserva onda T e segmento ST
- 45 Hz alta remove ru√≠do mantendo QRS (at√© ~40 Hz)

---

#### ‚û°Ô∏è `normalizar_sinal(sinal: np.ndarray, metodo: str = 'zscore') -> np.ndarray`

**Descri√ß√£o**: Normaliza o sinal usando diferentes m√©todos estat√≠sticos para padronizar amplitudes.

**Necessidade**: **CR√çTICA** - Amplitudes de ECG variam 10-100x entre pacientes, impossibilitando converg√™ncia de algoritmos ML.

**Par√¢metros**:
- `sinal`: Array numpy com shape (amostras, canais)
- `metodo`: M√©todo de normaliza√ß√£o ('zscore', 'minmax', 'robust')

**M√©todos Dispon√≠veis**:

1. **Min-Max**: `(x - min) / (max - min)`
   - Normaliza para intervalo [0, 1]
   - Sens√≠vel a outliers
   - √ötil para visualiza√ß√£o
   - **Prote√ß√£o**: Se range = 0, mant√©m sinal original

2. **Z-Score** (padr√£o): `(x - Œº) / œÉ`
   - Centraliza em zero com desvio padr√£o 1
   - Ideal para redes neurais e algoritmos baseados em gradiente
   - Preserva forma da distribui√ß√£o
   - **Prote√ß√£o**: Se œÉ = 0, subtrai apenas a m√©dia

3. **Robust**: `(x - mediana) / MAD`
   - Usa mediana e MAD (Median Absolute Deviation)
   - Resistente a outliers
   - Recomendado para dados cl√≠nicos com artefatos
   - **Prote√ß√£o**: Se MAD = 0, subtrai apenas a mediana

**Exemplo de uso**:
```python
# Normaliza√ß√£o Z-score (recomendada para ECG)
sinal_norm = normalizar_sinal(sinal, metodo='zscore')

# Normaliza√ß√£o robusta para dados com outliers
sinal_robust = normalizar_sinal(sinal, metodo='robust')
```

**Observa√ß√µes**:
- Amplitude varia de 0.1-5.0 mV (50x varia√ß√£o) inter-paciente
- Offset de -2 a +2 mV, inter-paciente
- Imped√¢ncia varia com eletrodos, pele e idade, inter-paciente
- **Prote√ß√µes robustas** contra divis√£o por zero implementadas
- Processamento por canal individual

---

### üü°
#### ‚û°Ô∏è `remover_baseline_drift(sinal: np.ndarray, fs: int, freq_corte: float = 0.5) -> np.ndarray`

**Descri√ß√£o**: Remove deriva da linha de base usando filtro passa-alta.

**Necessidade**: **IMPORTANTE** - Deriva afeta an√°lise de segmento ST e pode mascarar arritmias.

**Par√¢metros**:
- `sinal`: Array numpy com shape (amostras, canais)
- `fs`: Frequ√™ncia de amostragem
- `freq_corte`: Frequ√™ncia de corte para remo√ß√£o da deriva (Hz)

**Sobre Baseline Drift**:
- Deriva lenta da linha de base devido a respira√ß√£o, movimento do paciente, polariza√ß√£o de eletrodos ou varia√ß√£o de temperatura
- Frequ√™ncias t√≠picas: 0.05-0.5 Hz
- Pode afetar an√°lise de segmentos ST e medidas de amplitude

**Implementa√ß√£o**:
- Usa `aplicar_filtro()` internamente com tipo='highpass'
- Filtragem de fase zero para preservar morfologia
- Aplicado canal por canal automaticamente

**Exemplo de uso**:
```python
# Remo√ß√£o padr√£o de deriva (0.5 Hz)
sinal_sem_deriva = remover_baseline_drift(sinal, fs=500)

# Remo√ß√£o mais agressiva
sinal_limpo = remover_baseline_drift(sinal, fs=500, freq_corte=1.0)
```

---

#### ‚û°Ô∏è `detectar_outliers(sinal: np.ndarray, threshold: float = 3.0) -> np.ndarray`

**Descri√ß√£o**: Detecta outliers usando m√©todo z-score para identifica√ß√£o de artefatos.

**Necessidade**: **IMPORTANTE** - PTB-XL cont√©m artefatos cl√≠nicos que causam overfitting em modelos.

**Tipos detectados**: Artefatos de movimento, falhas de aquisi√ß√£o, interfer√™ncia de equipamentos.

**Par√¢metros**:
- `sinal`: Array numpy com shape (amostras, canais)
- `threshold`: Limite do z-score para considerar outlier (padr√£o: 3.0)

**Retorna**:
- Array booleano indicando posi√ß√µes dos outliers

**Prote√ß√µes Implementadas**:
- **Sinal constante**: Se œÉ = 0, nenhum outlier √© detectado
- **Processamento por canal**: Cada canal analisado independentemente
- **Valida√ß√£o de entrada**: Convers√£o autom√°tica para 2D se necess√°rio

**Interpreta√ß√£o dos Thresholds**:
- `threshold=2.0`: ~5% dos dados removidos (mais sens√≠vel)
- `threshold=3.0`: ~0.3% dos dados removidos (padr√£o)
- `threshold=4.0`: ~0.01% dos dados removidos (menos sens√≠vel)

**Exemplo de uso**:
```python
outliers = detectar_outliers(sinal, threshold=3.0)
print(f"Outliers detectados: {np.sum(outliers)} de {len(sinal)} amostras")

# Visualizar outliers
import matplotlib.pyplot as plt
plt.plot(sinal)
plt.scatter(np.where(outliers), sinal[outliers], color='red', s=20)
```

---

### üü¢ 
#### ‚û°Ô∏è `verificar_qualidade_sinal(sinal: np.ndarray, fs: int) -> Dict[str, Dict[str, float]]`

**Descri√ß√£o**: Calcula m√©tricas de qualidade do sinal para avalia√ß√£o autom√°tica.

**Necessidade**: **√öTIL** - Controle autom√°tico de qualidade para sistemas de produ√ß√£o e debug.

**M√©tricas Calculadas**:

1. **SNR Estimado**: `20 * log10(std(sinal) / (std(diff(sinal)) + 1e-10))`
   - **Interpreta√ß√£o**: >20 dB = boa qualidade, <10 dB = problem√°tico
   - **Baseado em**: Diferen√ßa entre variabilidade do sinal vs. ru√≠do
   - **Prote√ß√£o**: Adi√ß√£o de 1e-10 para evitar divis√£o por zero

2. **Amplitude M√°xima**: `max(abs(sinal))`
   - **Normal ECG**: 0.5-3.0 mV
   - **Problema**: >10 mV (satura√ß√£o), <0.1 mV (ganho baixo)

3. **Satura√ß√£o**: `% amostras > 95% do m√°ximo`
   - **Normal**: <1%
   - **Problema**: >5% indica satura√ß√£o do amplificador
   - **Prote√ß√£o**: Se amplitude_max = 0, satura√ß√£o = 0.0

4. **Zero Crossings**: `N√∫mero de cruzamentos por zero`
   - **Relacionado**: Conte√∫do de frequ√™ncia
   - **Anormal**: Muito baixo (deriva) ou muito alto (ru√≠do)

5. **RMS**: `sqrt(mean(sinal¬≤))`
   - **Energia**: Medida da pot√™ncia m√©dia do sinal
   - **√ötil**: Compara√ß√£o entre registros

**Prote√ß√µes Implementadas**:
- **Sinais constantes**: Tratamento especial para evitar divis√µes por zero
- **Valores extremos**: Prote√ß√µes contra overflow e underflow
- **Casting seguro**: Convers√£o expl√≠cita para float

**Exemplo de uso**:
```python
qualidade = verificar_qualidade_sinal(sinal, fs=500)
for canal, metricas in qualidade.items():
    if metricas['snr_estimado'] < 15:
        print(f"‚ö†Ô∏è {canal}: SNR baixo ({metricas['snr_estimado']:.1f} dB)")
```

---

#### ‚û°Ô∏è `pipeline_preprocessamento(filepath: str, aplicar_filtro_flag: bool = True, normalizar_flag: bool = True, remover_deriva: bool = True) -> Tuple[np.ndarray, Dict[str, Any]]`

**Descri√ß√£o**: Pipeline completo de pr√©-processamento com todas as etapas integradas.

**Necessidade**: **CONVENIENTE** - Garante reprodutibilidade e sequ√™ncia otimizada de processamento.

**Par√¢metros**:
- `filepath`: Caminho para arquivo de dados
- `aplicar_filtro_flag`: Se deve aplicar filtro passa-banda
- `normalizar_flag`: Se deve normalizar o sinal
- `remover_deriva`: Se deve remover deriva da linha de base

**Pipeline Padr√£o** (ordem otimizada):
1. Carregamento dos dados WFDB
2. **Valida√ß√£o inicial**: Verifica se sinal tem pelo menos 100 amostras (1s a 100Hz)
3. Remo√ß√£o de deriva da linha de base (0.5 Hz highpass) - se `remover_deriva=True`
4. Filtragem passa-banda (0.5-45 Hz) - se `aplicar_filtro_flag=True`
5. Normaliza√ß√£o Z-score - se `normalizar_flag=True`
6. Verifica√ß√£o de qualidade final

**POR QUE ESTA ORDEM**:
1. **Deriva primeiro**: Remove componentes de baixa frequ√™ncia que afetam filtros
2. **Filtro depois**: Opera em sinal com linha de base est√°vel
3. **Normaliza√ß√£o por √∫ltimo**: Aplica em sinal j√° limpo

**Valida√ß√µes e Prote√ß√µes**:
- **Sinal muito curto**: Warning para sinais < 100 amostras
- **Tratamento de erros**: RuntimeError com mensagem informativa
- **Qualidade integrada**: Metadados incluem m√©tricas de qualidade

**Exemplo de uso**:
```python
# Pipeline completo
sinal_processado, metadata = pipeline_preprocessamento('./data/00001_lr')

# Pipeline personalizado
sinal_custom, metadata = pipeline_preprocessamento(
    './data/00001_lr',
    aplicar_filtro_flag=True,
    normalizar_flag=False,  # Sem normaliza√ß√£o
    remover_deriva=True
)
```

---

#### ‚û°Ô∏è `salvar_dados_processados(sinal: np.ndarray, metadata: Dict[str, Any], ecg_id: int, output_dir: str = "../data/processed") -> Tuple[str, str]`

**Descri√ß√£o**: Salva dados processados em estrutura hier√°rquica organizacional com controle de vers√£o e rastreabilidade completa.

**Necessidade**: **CONVENIENTE** - Padroniza salvamento hier√°rquico escal√°vel para grandes datasets como PTB-XL.

**Par√¢metros**:
- `sinal`: Array numpy com sinal processado (n_samples, n_channels)
- `metadata`: Dicion√°rio com metadados completos do processamento
- `ecg_id`: Identificador num√©rico √∫nico do ECG (usado para organiza√ß√£o hier√°rquica)
- `output_dir`: Diret√≥rio base de destino (padr√£o: "../data/processed")

**Valida√ß√µes de Entrada Implementadas**:
- **Tipo do sinal**: Verifica se √© array numpy
- **ECG ID**: Deve ser positivo (>= 1)
- **Sinal vazio**: Verifica se sinal n√£o est√° vazio
- **Metadados**: Verifica se √© dicion√°rio v√°lido

**Retorna**:
- Tupla com caminhos dos arquivos salvos: `(arquivo_sinal, arquivo_metadata)`

**üóÇÔ∏è Estrutura Hier√°rquica Criada**:
```
../data/processed/
‚îú‚îÄ‚îÄ records000/              # ECGs 00001-01000
‚îÇ   ‚îú‚îÄ‚îÄ 00001_processed.npz
‚îÇ   ‚îú‚îÄ‚îÄ 00001_metadata.json
‚îÇ   ‚îú‚îÄ‚îÄ 00002_processed.npz
‚îÇ   ‚îú‚îÄ‚îÄ 00002_metadata.json
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ records001/              # ECGs 01001-02000
‚îÇ   ‚îú‚îÄ‚îÄ 01001_processed.npz
‚îÇ   ‚îú‚îÄ‚îÄ 01001_metadata.json
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ records002/              # ECGs 02001-03000
‚îî‚îÄ‚îÄ relatorio_*.csv          # Relat√≥rios na pasta raiz
```

**üìÅ Arquivos Gerados por ECG**:

1. **`{ecg_id:05d}_processed.npz`**: Sinal em formato NPZ compactado
   - Cont√©m: `sinal`, `ecg_id`, `timestamp`, `shape`, `fs`
   - Carregamento ultra-r√°pido com `np.load()`
   - Compress√£o autom√°tica para economia de espa√ßo

2. **`{ecg_id:05d}_metadata.json`**: Metadados estruturados completos
   - **`processamento`**: Timestamp, ID, pasta, vers√£o
   - **`dados_originais`**: Frequ√™ncia, canais, amostras, dura√ß√£o
   - **`qualidade`**: M√©tricas por canal (SNR, amplitude, satura√ß√£o)
   - **`estatisticas`**: Estat√≠sticas globais do sinal processado

**Estat√≠sticas Globais Calculadas**:
- Amplitude m√©dia, std, min, max, RMS global
- **Contagem de canais com boa qualidade** (SNR >= 15 dB)
- Casting seguro para tipos JSON-compat√≠veis

**üîç Exemplo de Conte√∫do dos Arquivos**:

**NPZ (carregamento)**:
```python
data = np.load('00001_processed.npz')
sinal = data['sinal']          # Array (n_samples, n_channels)
ecg_id = data['ecg_id']        # ID num√©rico
timestamp = data['timestamp']  # Quando foi processado
fs = data['fs']               # Frequ√™ncia de amostragem
```

**JSON (metadados estruturados)**:
```json
{
  "processamento": {
    "timestamp": "20250130_143022",
    "ecg_id": 1,
    "pasta_destino": "records000",
    "versao_preprocessing": "1.0"
  },
  "dados_originais": {
    "fs": 100,
    "sig_name": ["I", "II", "III", "aVR", "aVL", "aVF", "V1", "V2", "V3", "V4", "V5", "V6"],
    "n_samples": 1000,
    "n_channels": 12,
    "duracao_segundos": 10.0
  },
  "qualidade": {
    "canal_0": {
      "snr_estimado": 18.5,
      "amplitude_maxima": 1.245,
      "saturacao": 0.02,
      "rms": 0.156
    }
  },
  "estatisticas": {
    "amplitude_media_global": 0.001,
    "amplitude_std_global": 0.234,
    "amplitude_min_global": -1.234,
    "amplitude_max_global": 1.456,
    "amplitude_rms_global": 0.345,
    "canais_com_boa_qualidade": 11
  }
}
```

**üí° Exemplo de uso**:
```python
# Processamento individual
sinal_processado, metadata = pipeline_preprocessamento(filepath)
arquivos = salvar_dados_processados(
    sinal_processado, 
    metadata, 
    ecg_id=1,  # ID num√©rico do ECG
    output_dir="../data/processed"
)

# Carregamento posterior
data = np.load(arquivos[0])
sinal_carregado = data['sinal']

import json
with open(arquivos[1], 'r', encoding='utf-8') as f:
    metadata_carregado = json.load(f)
```

**üöÄ Vantagens da Estrutura Hier√°rquica**:
- **Performance**: M√°ximo 1000 arquivos por pasta (otimiza√ß√£o do filesystem)
- **Escalabilidade**: Suporta datasets grandes como PTB-XL (21K+ registros)
- **Organiza√ß√£o**: Estrutura similar aos dados raw para navega√ß√£o intuitiva
- **Busca R√°pida**: ID num√©rico permite localiza√ß√£o direta da pasta
- **Compatibilidade**: Padr√£o usado em datasets m√©dicos
- **Rastreabilidade**: Timestamping autom√°tico e controle de vers√£o

**üìä F√≥rmula da Organiza√ß√£o**:
```python
folder_number = (ecg_id - 1) // 1000
folder_name = f"records{folder_number:03d}"

# Exemplos:
# ECG 1     ‚Üí records000/
# ECG 1000  ‚Üí records000/
# ECG 1001  ‚Üí records001/
# ECG 2500  ‚Üí records002/
```

---

## ‚öôÔ∏è Configura√ß√µes por Contexto

### M√≠nima (Proof of Concept)
Uso: testes iniciais, prot√≥tipos r√°pidos, valida√ß√£o do c√≥digo.
```python
sinal, metadata = load_signal_data(filepath)
sinal = aplicar_filtro(sinal, metadata['fs'])
sinal = normalizar_sinal(sinal)

# Salvamento simples
arquivos = salvar_dados_processados(sinal, metadata, ecg_id=1)
```
- Objetivo: carregar, filtrar o ru√≠do e normalizar. Simples e direto.
- Sem verifica√ß√£o de qualidade, sem remo√ß√£o de outlier, sem deriva de linha de base.
- √ötil para ver se a estrutura geral do c√≥digo funciona.

### Robusta (Pesquisa)
Uso: experimentos com controle maior de qualidade, an√°lise explorat√≥ria em papers ou testes comparativos.
```python
sinal, metadata = pipeline_preprocessamento(
    filepath,
    aplicar_filtro_flag=True,
    normalizar_flag=True, 
    remover_deriva=True
)
outliers = detectar_outliers(sinal)

# Salvamento com rastreabilidade
arquivos = salvar_dados_processados(sinal, metadata, ecg_id=experiment_id)
```
- Usa um pipeline mais completo e parametrizado.
- Inclui: Filtro, Normaliza√ß√£o, Remo√ß√£o de baseline drift, Detec√ß√£o de outliers
- Boa pr√°tica para reprodutibilidade e an√°lise cient√≠fica.

### Produ√ß√£o (Sistema Cl√≠nico)
Uso: sistemas usados em ambiente real (ex: hospitais, dispositivos m√©dicos embarcados).
```python
sinal, metadata = pipeline_preprocessamento(filepath)
qualidade = metadata['qualidade']

# Verifica√ß√£o autom√°tica de qualidade
canais_ruins = []
for i in range(metadata['n_channels']):
    if qualidade[f'canal_{i}']['snr_estimado'] < 15:
        canais_ruins.append(metadata['sig_name'][i])

if len(canais_ruins) > 3:  # Mais de 3 canais ruins
    print(f"‚ö†Ô∏è Qualidade inadequada: {canais_ruins}")
    # Sinalizar para revis√£o manual
else:
    # Salvamento hier√°rquico para produ√ß√£o
    arquivos = salvar_dados_processados(
        sinal, metadata, 
        ecg_id=extrair_id_do_arquivo(filepath),
        output_dir="/dados/processados/producao"
    )
```
- Pipeline autom√°tico padronizado com verifica√ß√£o de qualidade
- Rejei√ß√£o autom√°tica de sinais abaixo do padr√£o
- Estrutura hier√°rquica para datasets grandes

---

## üìÅ Estrutura de Arquivos Gerados

### üóÇÔ∏è Organiza√ß√£o Hier√°rquica Completa
```
data/processed/
‚îú‚îÄ‚îÄ records000/                           # ECGs 00001-01000
‚îÇ   ‚îú‚îÄ‚îÄ 00001_processed.npz              # Sinal ECG 1
‚îÇ   ‚îú‚îÄ‚îÄ 00001_metadata.json              # Metadados ECG 1
‚îÇ   ‚îú‚îÄ‚îÄ 00002_processed.npz              # Sinal ECG 2
‚îÇ   ‚îú‚îÄ‚îÄ 00002_metadata.json              # Metadados ECG 2
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ records001/                           # ECGs 01001-02000
‚îÇ   ‚îú‚îÄ‚îÄ 01001_processed.npz
‚îÇ   ‚îú‚îÄ‚îÄ 01001_metadata.json
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ records002/                           # ECGs 02001-03000
‚îú‚îÄ‚îÄ relatorio_processamento_completo_20250130_143022.csv
‚îú‚îÄ‚îÄ relatorio_sucessos_20250130_143022.csv
‚îî‚îÄ‚îÄ relatorio_erros_20250130_143022.csv
```

### üìã Exemplo de Relat√≥rio CSV
```csv
ecg_id,patient_id,age,sex,status,snr_medio_original,snr_medio_final,melhoria_snr,canais_com_boa_qualidade,pasta_destino,arquivo_sinal
1,1,65,0,"‚úÖ Sucesso",16.2,19.8,3.6,12,records000,../data/processed/records000/00001_processed.npz
2,2,45,1,"‚úÖ Sucesso",14.1,18.2,4.1,11,records000,../data/processed/records000/00002_processed.npz
```

---

## üìã Par√¢metros Recomendados para ECG

### Filtragem
- **Passa-banda**: 0.5-45 Hz (padr√£o AHA/ACC para ECG)
- **Passa-alta**: 0.05-0.5 Hz (remo√ß√£o de deriva)
- **Passa-baixa**: 40-100 Hz (anti-aliasing)

### Normaliza√ß√£o
- **Z-score**: Para an√°lise de machine learning
- **Robust**: Para dados com artefatos
- **Min-max**: Para visualiza√ß√£o

### Qualidade do Sinal
- **SNR m√≠nimo**: 15-20 dB para an√°lise autom√°tica
- **Satura√ß√£o m√°xima**: < 1% das amostras
- **Frequ√™ncia de amostragem**: 100-500 Hz (PTB-XL: 100/500 Hz)

### Organiza√ß√£o de Arquivos
- **M√°ximo por pasta**: 1000 arquivos (otimiza√ß√£o filesystem)
- **Formato de dados**: NPZ compactado (velocidade + economia)
- **Metadados**: JSON estruturado (legibilidade + compatibilidade)

---

## üîó Integra√ß√£o com PTB-XL Dataset

Este m√≥dulo foi otimizado para trabalhar com:
- Arquivos WFDB (.hea/.dat)
- Frequ√™ncia de amostragem de 100/500 Hz
- 12 deriva√ß√µes padr√£o (I, II, III, aVR, aVL, aVF, V1-V6)
- 21,837 registros de 10 segundos
- Estrutura hier√°rquica escal√°vel para grandes volumes

---

## üì¶ Depend√™ncias

```python
import numpy as np                           # >= 1.19.0
import pandas as pd                          # >= 1.3.0  
import wfdb                                  # >= 3.4.0 (essencial para PTB-XL)
from scipy import signal                     # >= 1.7.0
from typing import Tuple, Optional, Union, Dict, Any
import json                                  # Biblioteca padr√£o
import os                                    # Biblioteca padr√£o
from datetime import datetime                # Biblioteca padr√£o
import warnings
```
---